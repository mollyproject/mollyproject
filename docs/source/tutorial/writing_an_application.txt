Writing an application
======================

A Molly application is a Python package with a certain layout.

Normally, you'll see:

.. code-block:: none

   myapp/
   ├ templates/
   │   └ myapp/
   │       ├ base.html
   │       ├ index.html
   │       └ [...]
   ├ templatetags/
   │   ├ __init__.py
   │   └ myapp.py
   ├ __init__.py
   ├ admin.py
   ├ forms.py
   ├ models.py
   ├ providers.py
   ├ urls.py
   └ views.py

Most of these follow the Django conventions, so if you're unfamiliar you
should consult the Django documentation.

The flow of a request
---------------------

Django despatches an incoming request to the callback given in a urlconf
which, in Molly, is a class object. Calling a class object is mapped to
calling it's ``__new__`` method. Ordinarily, this returns an instance of that
class, but in Molly it returns the response. Specifically:

.. class:: FooView

   .. classmethod:: __new__(request, *args, **kwargs):

      :param request: The request from the client to be processed.
      :type request: :class:`~django.http.HttpRequest`
      :rtype: :class:`~django.http.HttpResponse`

Unless overridden, the method called is
:meth:`molly.utils.views.BaseView.__new__`. This performs the following steps:

 * Checks there is a handler available for the HTTP method specified. If not,
   it immediately returns a ``405 Method Not Acceptable`` response.
 * Calls ``cls.initial_context(request, *args, **kwargs)``, which can provide
   context for all method handlers. A developer can use this to factor out
   code common between each of the handlers.
 * Evaluates the breadcrumbs and adds the resulting information to the
   context.
 * Calls the relevent handler, the name of which is determined by appending
   the method name to ``handle_``, e.g. ``handle_GET``. The handler is passed
   the request, context and any positional and keyword arguments.
 * The handler will update the context and perform any required actions as
   necessary.
 * The handler will generally return a :class:`~django.http.HttpResponse`
   subclass directly, or call the :meth:`~molly.utils.views.BaseView.render`
   method on :class:`~molly.utils.views.BaseView`.
 * In the latter case, :meth:`~molly.utils.views.BaseView.render` will
   determine which format to serialize to using a ``format`` query parameter
   or content negotiation, and despatch to a format-specific rendering method
   (e.g. :meth:`~molly.utils.views.BaseView.render_html`).
 * The renderer will return a :class:`~django.http.HttpResponse` object, which
   will then be passed back up the callstack to Django to be sent back to the
   client.

Views
-----

Molly uses class-based views to provide greater extensibility than
function-based views.

.. note::

   More information about Molly's use of class-based views can be found
   :doc:`here <class_based_views>`.

A basic view looks a little like this::

    from django.shortcuts import get_object_or_404
    from django.http import HttpResponseForbidden

    from molly.utils.views import BaseView
    from molly.utils.breadcrumbs import *
    from molly.http import HttpResponseSeeOther

    from .models import Thing
    from .forms import ThingUpdateForm

    class ThingDetailView(BaseView):
        def get_metadata(cls, request, thing_id):
            thing = get_object_or_404(Thing, id = thing_id)
            return {
                'title': thing.title,
                'additional': 'A %s thing with a %s leg.' % (thing.colour, thing.leg_type),
            }

        @BreadcrumbFactory
        def breadcrumb(cls, request, context, thing_id):
            return Breadcrumb(
                cls.conf.local_name,
                lazy_parent('things:index'),
                thing.title,
                lazy_reverse('things:detail', args=[thing_id]),
            )

        def initial_context(cls, request, thing_id):
            thing = get_object_or_404(Thing, id = thing_id)
            return {
                'thing': thing,
                'form': ThingUpdateForm(request.POST or None, instance = thing),
            }

        def handle_GET(cls, request, context, thing_id):
            return cls.render(request, context, 'things/thing_detail')

        def handle_POST(cls, request, context, thing_id):
            if not getattr(cls.conf, 'allow_edits', False):
                return HttpResponseForbidden()

            if context['form'].is_valid():
                context['form'].save()
                return HttpResponseSeeOther(reverse('things:detail'))
            else:
                return cls.handle_GET(request, context, thing_id)

For a 'basic' view, there's quite a lot going on here. Be [TODO]

Templates
---------

Referring to other views
""""""""""""""""""""""""

To get a link to another view, this can be generated by the
`Django url tag <http://docs.djangoproject.com/en/dev/ref/templates/builtins/#url>`_
using the namespace prefix of the app and the name of the view (as documented
on that application's page)

E.g., for the 'index' view of the contact app, the following template tag will
generate a URL::

   {% url contact:index %}